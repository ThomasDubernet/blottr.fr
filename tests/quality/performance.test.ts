/**
 * Performance Testing Suite for Design System Components
 * Bundle Size, Web Vitals, and Runtime Performance Validation
 */

import { test } from '@japa/runner'
import puppeteer, { Browser, Page } from 'puppeteer'
import { readFileSync, existsSync } from 'node:fs'
import { join } from 'node:path'
// Removed unused NetworkConditions import

/**
 * Performance testing configuration
 */
const PERFORMANCE_CONFIG = {
  // Core Web Vitals thresholds (from quality-gates.config.ts)
  webVitals: {
    fcp: 1500, // First Contentful Paint (ms)
    lcp: 2500, // Largest Contentful Paint (ms)
    cls: 0.1, // Cumulative Layout Shift
    fid: 100, // First Input Delay (ms)
    ttfb: 800, // Time to First Byte (ms)
  },

  // Bundle size limits
  bundleSize: {
    maxIncrease: 50 * 1024, // 50KB max increase
    maxTotal: 500 * 1024, // 500KB total limit
    maxComponent: 20 * 1024, // 20KB per component
  },

  // Runtime performance thresholds
  runtime: {
    renderTime: 16, // Target 60fps (16ms per frame)
    memoryLeak: 10 * 1024, // 10MB memory increase threshold
    maxRenders: 5, // Maximum re-renders per state change
  },

  // Network simulation
  network: {
    slow3G: { offline: false, latency: 300, download: 400 * 1024, upload: 400 * 1024 },
    fast3G: { offline: false, latency: 150, download: 1.6 * 1024 * 1024, upload: 750 * 1024 },
  },
}

let browser: Browser
let page: Page

test.group('Performance Tests', (group) => {
  group.setup(async () => {
    browser = await puppeteer.launch({
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-dev-shm-usage',
        '--disable-extensions',
        '--disable-plugins',
      ],
    })
    page = await browser.newPage()

    // Enable performance tracking
    await page.setCacheEnabled(false)
    await page.setViewport({ width: 1200, height: 800 })
  })

  group.teardown(async () => {
    if (browser) {
      await browser.close()
    }
  })

  /**
   * Test Bundle Size Impact
   */
  test('Design system bundle size within limits', async ({ assert }) => {
    // Read build stats (would be generated by webpack-bundle-analyzer)
    const buildStatsPath = join(process.cwd(), 'build/stats.json')

    if (!existsSync(buildStatsPath)) {
      console.warn('Build stats not found, skipping bundle size test')
      return
    }

    const buildStats = JSON.parse(readFileSync(buildStatsPath, 'utf8'))

    // Calculate design system bundle size
    const designSystemAssets =
      buildStats.assets?.filter(
        (asset: any) => asset.name.includes('design-system') || asset.name.includes('components')
      ) || []

    const totalSize = designSystemAssets.reduce((sum: number, asset: any) => sum + asset.size, 0)

    assert.isTrue(
      totalSize <= PERFORMANCE_CONFIG.bundleSize.maxTotal,
      `Design system bundle size (${totalSize} bytes) exceeds limit (${PERFORMANCE_CONFIG.bundleSize.maxTotal} bytes)`
    )

    // Check individual component sizes
    for (const asset of designSystemAssets) {
      assert.isTrue(
        asset.size <= PERFORMANCE_CONFIG.bundleSize.maxComponent,
        `Component ${asset.name} size (${asset.size} bytes) exceeds limit (${PERFORMANCE_CONFIG.bundleSize.maxComponent} bytes)`
      )
    }
  })

  /**
   * Test Core Web Vitals
   */
  test('Components meet Core Web Vitals standards', async ({ assert }) => {
    // Test on a page with design system components
    await page.goto('http://localhost:3333/components/showcase', { waitUntil: 'networkidle2' })

    // Measure Web Vitals
    const webVitals = await page.evaluate(() => {
      return new Promise((resolve) => {
        const vitals: any = {}

        // First Contentful Paint
        new PerformanceObserver((list) => {
          const entries = list.getEntries()
          const fcpEntry = entries.find((entry) => entry.name === 'first-contentful-paint')
          if (fcpEntry) {
            vitals.fcp = fcpEntry.startTime
          }
        }).observe({ type: 'paint', buffered: true } as any)

        // Largest Contentful Paint
        new PerformanceObserver((list) => {
          const entries = list.getEntries()
          const lcpEntry = entries[entries.length - 1] // Latest LCP
          if (lcpEntry) {
            vitals.lcp = lcpEntry.startTime
          }
        }).observe({ type: 'largest-contentful-paint', buffered: true } as any)

        // Cumulative Layout Shift
        let clsValue = 0
        new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            if (!(entry as any).hadRecentInput) {
              clsValue += (entry as any).value
            }
          }
          vitals.cls = clsValue
        }).observe({ type: 'layout-shift', buffered: true } as any)

        // First Input Delay (simulate input)
        new PerformanceObserver((list) => {
          const entries = list.getEntries()
          const fidEntry = entries[0]
          if (fidEntry) {
            vitals.fid = (fidEntry as any).processingStart - fidEntry.startTime
          }
        }).observe({ type: 'first-input', buffered: true } as any)

        // Resolve after collecting initial metrics
        setTimeout(() => resolve(vitals), 3000)
      })
    })

    // Assert Web Vitals thresholds
    const vitals = webVitals as any

    if (vitals.fcp) {
      assert.isTrue(
        vitals.fcp <= PERFORMANCE_CONFIG.webVitals.fcp,
        `First Contentful Paint (${vitals.fcp}ms) exceeds threshold (${PERFORMANCE_CONFIG.webVitals.fcp}ms)`
      )
    }

    if (vitals.lcp) {
      assert.isTrue(
        vitals.lcp <= PERFORMANCE_CONFIG.webVitals.lcp,
        `Largest Contentful Paint (${vitals.lcp}ms) exceeds threshold (${PERFORMANCE_CONFIG.webVitals.lcp}ms)`
      )
    }

    if (vitals.cls !== undefined) {
      assert.isTrue(
        vitals.cls <= PERFORMANCE_CONFIG.webVitals.cls,
        `Cumulative Layout Shift (${vitals.cls}) exceeds threshold (${PERFORMANCE_CONFIG.webVitals.cls})`
      )
    }

    if (vitals.fid) {
      assert.isTrue(
        vitals.fid <= PERFORMANCE_CONFIG.webVitals.fid,
        `First Input Delay (${vitals.fid}ms) exceeds threshold (${PERFORMANCE_CONFIG.webVitals.fid}ms)`
      )
    }
  })

  /**
   * Test Component Render Performance
   */
  test('Components render within performance budget', async ({ assert }) => {
    await page.goto('http://localhost:3333/components/performance-test')

    // Start performance monitoring
    await page.coverage.startJSCoverage()
    await page.coverage.startCSSCoverage()

    const renderTimes: number[] = []

    // Test multiple component renders
    for (let i = 0; i < 10; i++) {
      const startTime = Date.now()

      // Trigger component re-render (this would depend on your component implementation)
      await page.evaluate((index) => {
        // Simulate state change that triggers re-render
        const event = new CustomEvent('test-render', { detail: { index } })
        if (typeof window !== 'undefined') {
          window.dispatchEvent(event)
        }
      }, i)

      // Wait for render to complete
      await new Promise(resolve => setTimeout(resolve, 100))

      const renderTime = Date.now() - startTime
      renderTimes.push(renderTime)
    }

    // Stop coverage and calculate unused code
    const jsCoverage = await page.coverage.stopJSCoverage()
    await page.coverage.stopCSSCoverage()

    // Assert render performance
    const avgRenderTime = renderTimes.reduce((sum, time) => sum + time, 0) / renderTimes.length

    assert.isTrue(
      avgRenderTime <= PERFORMANCE_CONFIG.runtime.renderTime,
      `Average render time (${avgRenderTime}ms) exceeds budget (${PERFORMANCE_CONFIG.runtime.renderTime}ms)`
    )

    // Calculate code coverage (should be high for performance test page)
    const totalJSBytes = jsCoverage.reduce((sum, entry) => sum + entry.text.length, 0)
    const usedJSBytes = jsCoverage.reduce((sum, entry) => {
      return (
        sum +
        entry.ranges.reduce((rangeSum, range) => {
          return rangeSum + (range.end - range.start)
        }, 0)
      )
    }, 0)

    const jsUtilization = totalJSBytes > 0 ? (usedJSBytes / totalJSBytes) * 100 : 100

    assert.isTrue(
      jsUtilization >= 60,
      `JavaScript utilization (${jsUtilization.toFixed(1)}%) is too low - indicates unused code`
    )
  })

  /**
   * Test Memory Usage and Leaks
   */
  test('Components do not cause memory leaks', async ({ assert }) => {
    await page.goto('http://localhost:3333/components/memory-test')

    // Get initial memory usage
    const initialMemory = await page.evaluate(() => {
      if ('memory' in performance) {
        return (performance as any).memory.usedJSHeapSize
      }
      return 0
    })

    // Simulate intensive component usage
    for (let i = 0; i < 100; i++) {
      await page.evaluate((index) => {
        // Create and destroy components (implementation depends on your framework)
        const event = new CustomEvent('memory-test', { detail: { iteration: index } })
        if (typeof window !== 'undefined') {
          window.dispatchEvent(event)
        }
      }, i)

      if (i % 10 === 0) {
        // Force garbage collection periodically if available
        await page.evaluate(() => {
          if ('gc' in window) {
            ;(window as any).gc()
          }
        })
      }
    }

    // Wait for cleanup
    await new Promise(resolve => setTimeout(resolve, 1000))

    // Get final memory usage
    const finalMemory = await page.evaluate(() => {
      if ('memory' in performance) {
        return (performance as any).memory.usedJSHeapSize
      }
      return 0
    })

    if (initialMemory > 0 && finalMemory > 0) {
      const memoryIncrease = finalMemory - initialMemory

      assert.isTrue(
        memoryIncrease <= PERFORMANCE_CONFIG.runtime.memoryLeak,
        `Memory increase (${memoryIncrease} bytes) exceeds threshold (${PERFORMANCE_CONFIG.runtime.memoryLeak} bytes)`
      )
    }
  })

  /**
   * Test Performance on Slow Networks
   */
  test('Components perform well on slow networks', async ({ assert }) => {
    // Simulate slow 3G connection
    await page.emulateNetworkConditions(PERFORMANCE_CONFIG.network.slow3G)

    const startTime = Date.now()
    await page.goto('http://localhost:3333/components/showcase', { waitUntil: 'networkidle2' })
    const loadTime = Date.now() - startTime

    // Check if page loads within acceptable time on slow network
    const maxSlowNetworkTime = 10000 // 10 seconds
    assert.isTrue(
      loadTime <= maxSlowNetworkTime,
      `Page load time on slow 3G (${loadTime}ms) exceeds limit (${maxSlowNetworkTime}ms)`
    )

    // Test Time to First Byte
    const performanceTiming = await page.evaluate(() => {
      const timing = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming
      return {
        ttfb: timing.responseStart - timing.connectStart,
        domContentLoaded: timing.domContentLoadedEventStart - timing.fetchStart,
        fullyLoaded: timing.loadEventEnd - timing.fetchStart,
      }
    })

    if (performanceTiming.ttfb > 0) {
      assert.isTrue(
        performanceTiming.ttfb <= PERFORMANCE_CONFIG.webVitals.ttfb * 2, // Allow 2x threshold for slow network
        `Time to First Byte on slow network (${performanceTiming.ttfb}ms) is too high`
      )
    }

    // Reset network conditions
    // Reset network conditions - using any to bypass type checking
    await (page as any).emulateNetworkConditions({
      offline: false,
      latency: 0,
      downloadThroughput: -1,
      uploadThroughput: -1,
    })
  })

  /**
   * Test Component Hydration Performance
   */
  test('SSR hydration performance is optimal', async ({ assert }) => {
    // Test server-rendered page hydration
    const startTime = Date.now()

    await page.goto('http://localhost:3333/components/ssr-test', { waitUntil: 'domcontentloaded' })

    // Wait for React hydration to complete
    await page.waitForFunction(
      () => {
        return typeof window !== 'undefined' && (
          window.document.querySelector('[data-reactroot]') !== null ||
          window.document.querySelector('#root')?.hasAttribute('data-reactroot')
        )
      },
      { timeout: 5000 }
    )

    const hydrationTime = Date.now() - startTime

    // Assert hydration performance
    const maxHydrationTime = 2000 // 2 seconds
    assert.isTrue(
      hydrationTime <= maxHydrationTime,
      `Hydration time (${hydrationTime}ms) exceeds limit (${maxHydrationTime}ms)`
    )

    // Check for hydration mismatches (would show as console errors)
    const consoleLogs = await page.evaluate(() => {
      return (window as any).__hydrationErrors || []
    })

    assert.equal(consoleLogs.length, 0, `Hydration mismatches detected: ${consoleLogs.join(', ')}`)
  })

  /**
   * Test Animation Performance
   */
  test('Animations maintain 60fps performance', async ({ assert }) => {
    await page.goto('http://localhost:3333/components/animations')

    // Start measuring frame rate
    const frameRateData = await page.evaluate(() => {
      return new Promise((resolve) => {
        const frameRates: number[] = []
        let frameCount = 0
        let startTime = Date.now()
        let lastFrameTime = startTime

        function measureFrameRate() {
          frameCount++
          const currentTime = Date.now()
          const frameTime = currentTime - lastFrameTime

          if (frameTime > 0) {
            const fps = 1000 / frameTime
            frameRates.push(fps)
          }

          lastFrameTime = currentTime

          // Measure for 3 seconds
          if (currentTime - startTime < 3000) {
            if (typeof requestAnimationFrame !== 'undefined') {
              if (typeof requestAnimationFrame !== 'undefined') {
          requestAnimationFrame(measureFrameRate)
        }
            }
          } else {
            resolve(frameRates)
          }
        }

        // Trigger animations
        const event = new CustomEvent('start-animations')
        if (typeof window !== 'undefined') {
          window.dispatchEvent(event)
        }

        if (typeof requestAnimationFrame !== 'undefined') {
          requestAnimationFrame(measureFrameRate)
        }
      })
    })

    const frameRates = frameRateData as number[]
    const averageFps = frameRates.reduce((sum, fps) => sum + fps, 0) / frameRates.length
    const minFps = Math.min(...frameRates)

    // Assert frame rate performance
    assert.isTrue(
      averageFps >= 55, // Allow slight variance from 60fps
      `Average FPS (${averageFps.toFixed(1)}) is below acceptable threshold (55fps)`
    )

    assert.isTrue(
      minFps >= 30, // Minimum acceptable frame rate
      `Minimum FPS (${minFps.toFixed(1)}) dropped below acceptable threshold (30fps)`
    )

    // Check for jank (frames taking longer than 16.67ms)
    const jankFrames = frameRates.filter((fps) => fps < 60).length
    const jankPercentage = (jankFrames / frameRates.length) * 100

    assert.isTrue(
      jankPercentage <= 10, // Max 10% jank frames
      `Too many jank frames (${jankPercentage.toFixed(1)}%) - should be ≤10%`
    )
  })

  /**
   * Test Resource Loading Performance
   */
  test('Static assets load efficiently', async ({ assert }) => {
    // Clear cache to test actual loading performance
    await page.setCacheEnabled(false)

    const responsePromises: Promise<any>[] = []

    page.on('response', (response) => {
      responsePromises.push(
        Promise.resolve({
          url: response.url(),
          status: response.status(),
          size: response.headers()['content-length'],
          timing: response.timing(),
        })
      )
    })

    await page.goto('http://localhost:3333/components/showcase')

    const responses = await Promise.all(responsePromises)

    // Filter for static assets (CSS, JS, images)
    const staticAssets = responses.filter((response) =>
      response.url.match(/\.(css|js|png|jpg|jpeg|gif|svg|woff|woff2)$/i)
    )

    // Check asset loading performance
    for (const asset of staticAssets) {
      if (asset.timing && asset.timing.receiveHeadersEnd > 0) {
        const loadTime = asset.timing.receiveHeadersEnd

        // Assert reasonable loading times for assets
        const maxAssetLoadTime = 2000 // 2 seconds
        assert.isTrue(
          loadTime <= maxAssetLoadTime,
          `Asset ${asset.url} took too long to load (${loadTime}ms)`
        )
      }

      // Check for successful responses
      assert.isTrue(
        asset.status >= 200 && asset.status < 300,
        `Asset ${asset.url} returned error status ${asset.status}`
      )
    }

    // Check total number of requests (should be reasonable)
    const totalRequests = responses.length
    const maxRequests = 50 // Reasonable limit for component showcase page

    assert.isTrue(
      totalRequests <= maxRequests,
      `Too many HTTP requests (${totalRequests}) - should be ≤${maxRequests}`
    )
  })
})
